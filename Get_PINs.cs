namespace CodeWars_Task
{
    //    Итак, детектив, один из наших коллег успешно обнаружил нашу цель, грабителя Робби.Следуем за ним на секретный склад, где предполагаем найти все украденное.Дверь в этот склад защищена электронным кодовым замком.К сожалению, наш шпион не уверен в ПИН-коде, который он видел, когда Робби ввел его.

    //Клавиатура имеет следующую компоновку:

    //┌───┬───┬───┐
    //│ 1 │ 2 │ 3 │
    //├───┼───┼───┤
    //│ 4 │ 5 │ 6 │
    //├───┼───┼───┤
    //│ 7 │ 8 │ 9 │
    //└───┼───┼───┘
    //    │ 0 │
    //    └───┘
    //Он отметил PIN-код 1357, но также сказал, что возможно, что каждая из цифр, которые он видел, на самом деле может быть другой соседней цифрой (по горизонтали или вертикали, но не по диагонали). Например, вместо этого 1также может быть 2или 4. А вместо, 5это может быть 2, 4, 6или 8.

    //Он также упомянул, что знает такие замки.Вы можете ввести неограниченное количество неправильных PIN-кодов, они никогда не заблокируют систему окончательно и не подадут сигнал тревоги.Вот почему мы можем попробовать все возможные (*) варианты.

    //* возможно в смысле: самого наблюдаемого PIN-кода и всех вариаций с учетом соседних цифр

    //Можете ли вы помочь нам найти все эти варианты? Было бы неплохо иметь функцию, которая возвращает массив (или список в Java/Kotlin и C#) всех вариантов наблюдаемого PIN-кода длиной от 1 до 8 цифр. Мы могли бы назвать функцию getPINs( get_pinsв python, GetPINsв C#). Но обратите внимание, что все PIN-коды, как наблюдаемые, так и результаты, должны быть строками из-за потенциально ведущих нулей. Мы уже подготовили для вас несколько тестовых случаев.

    public class Get_PINs
    {
        public static List<string> GetPINs(string observed)
        {
           var pin = new Dictionary<char, List<string>>()
            {
                {'1', new List<string>(){"1","2","4"}},
                {'2', new List<string>(){"1","2","3","5" } },
                {'3', new List<string>(){"2","3","6" } },
                {'4', new List<string>(){"4","1","7","5" } },
                {'5', new List<string>(){"5","4","6","2","8" } },
                {'6', new List<string>(){"6","3","9","5"} },
                {'7', new List<string>(){"7","8","4" } },
                {'8', new List<string>(){"8","7","9","5","0" } },
                {'9', new List<string>(){"9","8","6" } },
                {'0', new List<string>(){"0","8"} },
            };
            var char_list = observed.ToCharArray();
            var result = new List<string>();
            for (int i = 0; i < char_list.Count(); i++)
            {
                var curent = new List<string>();
                pin.TryGetValue(char_list[i], out curent);
                if (i == 0)
                {
                    result.AddRange(curent);
                }
                else
                {
                    result = result.SelectMany(a => curent, (a, b) => a + b).ToList();
                }
            }
            return result.ToList();
        }
    }

    //
    //{
    //    var result = new List<string>
    //{
    //  ""
    //};

    //    foreach (var c in observed)
    //    {
    //        result =
    //          (from r in result
    //           from a in AdjacentKeys[c]
    //           select $"{r}{a}").ToList();
    //    }

    //    return result;
    //}

    //public static Dictionary<char, IEnumerable<string>> AdjacentKeys =
    //  new Dictionary<char, IEnumerable<string>>()
    //{
    //{ '1', new[] { "1", "2", "4" } },
    //{ '2', new[] { "1", "2", "3", "5" } },
    //{ '3', new[] { "2", "3", "6" } },
    //{ '4', new[] { "1", "4", "5", "7" } },
    //{ '5', new[] { "2", "4", "5", "6", "8" } },
    //{ '6', new[] { "3", "5", "6", "9" } },
    //{ '7', new[] { "4", "7", "8" } },
    //{ '8', new[] { "5", "7", "8", "9", "0" } },
    //{ '9', new[] { "6", "8", "9" } },
    //{ '0', new[] { "8", "0" } }
    //};

    public class ExampleTests
    {
        [Test]
        public void TestBasic()
        {
            var expectations = new Dictionary<string, string[]>{
        { "8", new[] { "5", "7", "8", "9", "0" } },
        {"11",  new[]{"11", "22", "44", "12", "21", "14", "41", "24", "42" } },
        {"369", new[] { "339","366","399","658","636","258","268","669","668","266","369","398","256","296","259","368","638","396","238","356","659","639","666","359","336","299","338","696","269","358","656","698","699","298","236","239" } }
  };

            foreach (var pin in expectations)
            {
                CollectionAssert.AreEquivalent(pin.Value, Get_PINs.GetPINs(pin.Key), "PIN: " + pin);
            }
        }
    }
}
